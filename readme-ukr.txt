ЗАВДАННЯ 1
Із сигнатури
const Segment& Triangle::median(const Segment& side) const
видно, що медіана має десь зберігатись, щоб на неї можна було повернути посилання.
Для цього, в класі Трикутників зберігаються mutable указники на сторони (медіани) (агрегація указниками). Вони ініціалізуються нулями і обраховуються тоді, коли їх вперше замовлять. Якщо точки трикутника зміняться, то і медіани зміняться, тому після таких змін старі медіани видаляються і указники обнулюються. Медіани mutable для того, щоб їх можна було порахувати і для сталого трикутника.

ЗАВДАННЯ 2 і 3
Клас Calendar містить перелік днів тижня, а також їх імена. У нього є методи, які видають день з переліку або стрічку з ім'ям за заданою датою.

Також містить масив з датами державних свят фіксованого розміру (бо свят однакова кількість кожного року). Масив нестатичний і залежить від атрибуту _year, оскільки є свята (Великдень і Трійця), дати яких залежать від року. Містить статичний масив з назвами свят.
Також у класі визначені методи, що дозволяють дізнатися, чи є задана дата вихідним, святом або робочим днем (не вихідний і не свято).

ЗАВДАННЯ 4 і 5
Відміну сигналу будильника непогано було б реалізувати через потоки, але ми їх ще не вчили. Тому будильник очікує відміни таким чином: питає в користувача (виводить в cin) чи хоче він відмінити сигнал, допоки користовач не скаже 'y', або допоки не закінчиться час очікування, визначений налаштуванням класу. Якщо сигнал не був відмінений, він повторюється і знову починається очікування відміни. І так допоки сигнал не буде відмінений.

ЗАВДАННЯ 6
Між кожним сигналом будильника він спить приблизно 1 день (1 день мінус той час, який будо витрачено на відміну сигналу*). Кожного дня будильник перевіряє, чи є сьогоднішній день робочим, і якщо так, то починається сигнал. Також кожного дня будильник перевіряє, чи не треба змінити календар на інший рік і, якщо треба, змінює.
*відміна сигналу відміняє сигнал, який лунає у даний момент, а не весь будильник, будильник все одно спрацює наступного робочого дня.

ЗАВДАННЯ 7
У класі пар є конструктор за замовчуванням для того, щоб їх можна було покласти в масив (для використання у стеку), оскільки при створенні масиву ініціалізуються усі його елементи.
Також реалізовані оператори порівняння для пар (за ключем).

ЗАВДАННЯ 8
У якості контейнеру для елементів масиву використала Sequence, тому що вона містить необхідний функціонал.

Операція push виконується за обмежений час завдяки тому, що додає елемент в кінець послідовності. Тобто для виконання цієї операції потрібно перезаписати одну комірку масиву, час константний*.
* але час від часу змінюється розмір масиву, щоб вмістити усі елементи або, навпаки, щоб не було забагато вільного місця, отже час витрачається ще на це

Тоді для операцій top і pop потрібно спочатку знайти потрібний індекс. Індекс шукається з кінця послідовності до початку. У найгіршому випадку шуканий елемент знаходиться на початку послідовності, отже час: O(N), де N - кількіть елементів у стеку.

ЗАВДАННЯ 9
Операції top і pop виконуються за обмежений час завдяки тому, що елементи знаходяться у послідовності вже в правильному порядку, і потрібно лише взяти останній елемент для top або вкоротити послідовність (cut) для pop. Тобто для виконання цих операції потрібно або доступитись до комірки масиву, або декрементувати змінну розміру, час константний час*.
* час від часу змінюється розмір масиву

Тоді для операції push потрібно спочатку знайти потрібний індекс, на який вставити новий елемент. Індекс шукається з кінця послідовності до початку. У найгіршому випадку шуканий елемент знаходиться на початку послідовності, отже час: O(N), де N - кількіть елементів у стеку.

ЗАВДАННЯ 10
Класи із задач 8 і 9 об'єднані за допомогою Non Virtual Interface, вільного від заміщень (щоб не можна було перевизначити інтерфейсні функції у похідних класах).
Обрала NVI для того, щоб відділити частини базового класу, відповідальні за успадкування інтерфейсу і за визначення поведінки.

Нереалізовані у базовому класі інтерфейсні функціїї викликають закриті нереалізовані віртуальні функції, які будуть реалізовані у похідних класах.
